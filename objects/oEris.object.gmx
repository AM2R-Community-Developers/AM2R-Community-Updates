<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>sErisHead</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>-80</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>canbeX = 1;
//hp = 100;
hp = global.mod_serrisHealth;
if (global.item[11] == 0) {
    hp = hp * 2;
}
//damage = 50;
damage = global.mod_serrisDamage;
phase = 0;
bodylength = 16; //16
stepdelay = 1;
flashing = 0;
roaring = 0;
inrange = 0;
facing = 1;
speed = 0;
turnspeed = 4;
speedmult = 1;
stun = 0;

for (i = 1; i &lt; bodylength - 1; i += 1) { //bodylength - 1 OG
    if (i &gt;= 4) {
        mybody[i] = instance_create(10, 264, oErisBody1);
        if (i &gt;= 13) {
            mybody[i].spr_normal = sErisNeck;
            mybody[i].spr_frozen = sErisNeckF;
            mybody[i].spr_open = sErisNeckD;
        }
    } else {
        mybody[i] = instance_create(10, 264, oErisBody2);
    }
    mybody[i].depth = -50 - i;
    mybody[i].order = i;

}
tailobj = instance_create(10, 264, oErisBody3);
stepstaken = 0;

for (l = 0; l &lt;= bodylength; l += 1) {
    prev_x[l] = ds_queue_create();
    prev_y[l] = ds_queue_create();
}
state = 10;
nextstate = 0;
statetime = 0;
tgt = 0;
i = 0;
repeat (20) {
    targetx[i] = x;
    targety[i] = y;
    i += 1;
}
jawoff = 0;
tgtx = x;
tgty = y;
startx = x;
alarm[0] = 1;
alarm[1] = 120;

tailx = 0;
taily = 0;

boosting = 0;
fxtimer = 0;
boostphase = 0;
boostspdmult = 1;
boostspddelay = 1;
stepdelayfinal = stepdelay;
use2 = 0;






</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="1" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if(oControl.mod_fusion == 0) monster_spawn_powerups(x, y, random(4), random(3));
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="1">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>var sfx;
sfx = choose(0, 1, 2);
if (inrange) switch (sfx) {
    case 0: sfx_play(sndErisMove1); break;
    case 2: sfx_play(sndErisMove2); break;
    case 3: sfx_play(sndErisMove3); break;
}
alarm[1] = 60 + random(90);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if (state != 100 &amp;&amp; inrange) {
    bubble = instance_create(x, y - 8, oLBubble);
    if (instance_exists(bubble)) {
        bubble.alarm[0] = 60;
        bubble.direction = image_angle;
        bubble.speed = speed * 0.6;
        bubble.depth = -90;
    }
}
alarm[0] = 4 + random(4);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="2">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if (state != 100) {
    for (j = 0; j &lt; bodylength; j += 1) {
        if (round(j) == 0) {
            prevsegment = -1;
            segment = mybody[bodylength - 2];
        }
        if (round(j) == 1) {
            prevsegment = -1;
            segment = mybody[bodylength - 2];
        }
        if ((j &gt; 1) &amp;&amp; (j &lt; bodylength - 1)) {
            prevsegment = mybody[j];
            segment = mybody[j - 1];
        }
        if (round(j) == (bodylength - 1)) {
            prevsegment = mybody[1];
            segment = tailobj;
        }
        //if (j == (bodylength - 2)) { }
        ds_queue_enqueue(prev_x[round(j)], prevsegment.x);
        ds_queue_enqueue(prev_y[round(j)], prevsegment.y);
        if (ds_queue_size(prev_x[round(j)]) &gt; stepdelay) {
            //show_debug_message("Trigger");
            segment.x = ds_queue_head(prev_x[round(j)]);
            segment.y = ds_queue_head(prev_y[round(j)]);
            ds_queue_dequeue(prev_x[round(j)]);
            ds_queue_dequeue(prev_y[round(j)]);
        }
    } // for (j = 0; j &lt; bodylength; j += 1)
} // if (state != 100)
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>inrange = (x &gt; 32) &amp;&amp; (x &lt; 608) &amp;&amp; (y &gt; 48) &amp;&amp; (y &lt; 448);
//if (instance_exists(oErisBody3)) tailx = tailobj.x;
//if (instance_exists(oErisBody3)) taily = tailobj.y;
if (state == 10) {
    if (statetime == 0) {
        facing = -1;
        x = 720;
        startx = 720;
        direction = 180;
        image_yscale = -1;
        event_user(0);
    }
    if (statetime == 120) sfx_play(sndErisRoar1);
    if (statetime == 180) {
        boosting = 1; // spawn in boosting
        state = 2;
        statetime = 0;
        mus_play(musEris);
        oMusicV2.bossbgm = musEris;
        scan_log(37, get_text("ScanEvents", "ScanBioform"), 120, 0);
    }
}
if (state == 0) {
    nextstate += 1;
    if (nextstate &gt; 3) nextstate = 1;
    if (statetime == 0) {
        switch (nextstate) {
            case 1: sfx_play(sndErisRoar1); break;
            case 2: sfx_play(sndErisRoar2); break;
            case 3: sfx_play(sndErisRoar3); break;
            case 4: sfx_play(sndErisRoar4); break;
        }
        facing = choose(1, -1);
        if (facing == 1) {
            x = -64;
            startx = -64;
            direction = 0;
            image_yscale = 1;
            event_user(0);
        } else {
            x = 720;
            startx = 720;
            direction = 180;
            image_yscale = -1;
            event_user(0);
        }
    }
    
    // boosting
    if (boostphase == 1) { // trigger
        boostphase = 2; // wait
        boosting = 4; // boost steps
    } else if (boostphase == 3) { // trigger
        boostphase = 4; // wait
        boosting = 5; // boost steps
    } else if (boostphase == 5) { // trigger
        boostphase = 6; // wait
        boosting = 6; // boost steps
    }
    if (boosting &gt; 0) boosting --;
    
    // move to state
    if (statetime == (90 - (sign(boosting)*90))) {
        state = nextstate;
        statetime = 0;
    }
    
} // if (state == 0)
if (state == 1) {
    if (statetime == 0) {
        event_user(1);
        tgt = 0;
        y = 240;
        turnspeed = 2 * speedmult * 1.2;
        event_user(4); // projectiles
    }
    
    if (statetime &gt; 300) turnspeed += 0.1;
    targetx[0] = startx + 160 * facing;
    targety[0] = 304;
    targetx[1] = startx + 320 * facing;
    targety[1] = 416;
    targetx[2] = startx + 480 * facing;
    targety[2] = 304;
    targetx[3] = startx + 320 * facing;
    targety[3] = 144;
    targetx[4] = startx + 160 * facing;
    targety[4] = 300;
    targetx[5] = startx + -60 * facing;
    targety[5] = 288;
    if (tgt &lt; 6) {
        if (stun == 0) {
            speed = 4 * speedmult;
        } else speed = 4 * speedmult;
    }
    if (tgt == 6 &amp;&amp; (x &lt; 0 || x &gt; 640)) {
        speed = 0;
        if (tailobj.x == x &amp;&amp; tailobj.y == y) {
            state = 0;
            statetime = -1;
        }
    }
} // if (state == 1)
if (state == 2) {
    if (statetime == 0) {
        event_user(1);
        tgt = 0;
        y = 144;
        turnspeed = 2 * speedmult * 1.2;
        event_user(4); // projectiles
    }
    if (statetime &gt; (300-(sign(boosting)*150))) turnspeed += 0.1;
    targetx[0] = startx + (160 * facing);
    targety[0] = 144;
    targetx[1] = startx + (448 * facing);
    targety[1] = 416;
    targetx[2] = startx + (576 * facing);
    targety[2] = 368;
    targetx[3] = startx + (528 * facing);
    targety[3] = 112;
    targetx[4] = startx + (160 * facing);
    targety[4] = 432;
    targetx[5] = startx + (160 * facing);
    targety[5] = 416;
    targetx[6] = startx + (-60 * facing);
    targety[6] = 416;
    if (tgt &lt; 7 &amp;&amp; ((x &lt; 0) || (x &gt; 640))) {
        if (stun == 0) {
            speed = 4 * speedmult;
        } else speed = 0;
    }
    if (round(tgt) == 7) {
        speed = 0;
        if ((tailobj.x == x) &amp;&amp; (tailobj.y == y)) {
            state = 0;
            statetime = -1;
        }
    }
} // if (state == 2)
if (state == 3) {
    if (statetime == 0) {
        event_user(1);
        tgt = 0;
        tgtx = oCharacter.x;
        tgty = oCharacter.y;
        turnspeed = 4 * speedmult * 1.2;
        event_user(4); // projectiles
    }
    if (statetime &gt; 300) turnspeed += 0.1;
    targetx[0] = startx + 80 * facing;
    targety[0] = y;
    targetx[1] = startx + 160 * facing;
    targety[1] = tgty - 64;
    targetx[2] = startx + 240 * facing;
    targety[2] = tgty + 64;
    targetx[3] = startx + 320 * facing;
    targety[3] = tgty - 64;
    targetx[4] = startx + 400 * facing;
    targety[4] = tgty + 64;
    targetx[5] = startx + 480 * facing;
    targety[5] = tgty - 64;
    targetx[6] = startx + 560 * facing;
    targety[6] = 144;
    targetx[7] = startx + 740 * facing; // 720
    targety[7] = 144;
    if (tgt &lt; 8 &amp;&amp; (x &lt; 0 || x &gt; 640)) {
        if (stun == 0) {
            speed = 4 * speedmult;
        } else speed = 0;
    }
    if (tgt == 8) {
        speed = 0;
        if (tailobj.x == x &amp;&amp; tailobj.y == y) {
            state = 0;
            statetime = -1;
        }
    }
} // if (state == 3)
if (state == 4) {
    if (statetime == 0) {
        event_user(1);
        tgt = 0;
        y = 240;
        turnspeed = 4 * speedmult * 1.2;
    }
    if (statetime &gt; 300) turnspeed += 0.1;
    if (tgt &lt; 2 &amp;&amp; point_distance(x, y, oCharacter.x, oCharacter.y - 16) &gt; 120) {
        tgtx = oCharacter.x;
        tgty = oCharacter.y - 16;
    }
    targetx[0] = startx + 96 * facing;
    targety[0] = 112;
    targetx[1] = tgtx;
    targety[1] = tgty;
    targetx[2] = tgtx + lengthdir_x(64, image_angle);
    targety[2] = tgty + lengthdir_y(64, image_angle);
    targetx[3] = startx + 720 * facing;
    targety[3] = 288;
    if (tgt &lt; 4) {
        if (stun == 0) {
            speed = 4 * speedmult;
        } else speed = 0;
    }
    if (tgt == 4 &amp;&amp; (x &lt; 0 || x &gt; 640)) {
        speed = 0;
        if (tailobj.x == x &amp;&amp; tailobj.y == y) {
            state = 0;
            statetime = -1;
        }
    }
} // if (state == 4)
if (state == 100) {
    if (statetime &lt; 30) {
        speed *= 0.8;
    } else if (vspeed &gt; -0.2) vspeed -= 0.01;
    if (statetime == 0) {
        for (i = 1; i &lt; bodylength - 1; i += 1) {
            with (mybody[i]) event_user(10);
        }
        //tailx = tailobj.x; //added
        //taily = tailobj.y; //added
        with (tailobj) instance_destroy();
        sfx_play(sndErisDeath);
        if(oControl.mod_fusion == 0) {
            mus_fadeout(musEris);
            oMusicV2.bossbgm = sndJump;
        }
    }
    if (statetime == 280) {
        repeat (8) {
            expl = instance_create(x + random_range(-16, 16), y + random_range(-16, 16), oFXAnimSpark);
            expl.image_speed = 0.3 + random(0.5);
            expl.additive = 0;
            expl.sprite_index = sExpl1;
        }
        make_explosion3(x, y);
        repeat (20) {
            bubble = instance_create(x, y, oLBubble);
            if (instance_exists(bubble)) {
                bubble.hspeed = random_range(-2.5, 2.5);
                bubble.vspeed = -random(0.4);
            }
        }
        instance_create(x, y, oScreenFlash);
        sfx_play(sndMissileExpl);
        
        global.event[261] = 1;
        
        if(oControl.mod_fusion == 0) {
            with (oDoorA5) event_user(3);
            mus_current_fadein();
        } 
        else {
            core = instance_create(mean(bbox_left, bbox_right), mean(bbox_top, bbox_bottom), oCoreX);
            core.lastBossX = x;
            core.lastBossY = y;
            core.lastBossSprite = sprite_index;
            core.lastBossFrame = image_index;
            core.lastBossAngle = image_angle;
            core.lastBossFacing = 1;
            core.lastYscale = image_yscale;
            core.lastBossDepth = depth;
        }
        
        instance_destroy();
    }
} // if (state == 100)
if (state != 100) {
    if (point_distance(x, y, targetx[tgt], targety[tgt]) &lt; 32 &amp;&amp; speed != 0) tgt += 1;
    turn_towards_direction(point_direction(x, y, targetx[tgt], targety[tgt]), turnspeed);
    image_angle = direction;
}
if (roaring &gt; 0) {
    if (jawoff &lt; 6) jawoff += 2;
} else if (jawoff &gt; 0) jawoff -= 1;
statetime += 1;
if (roaring &gt; 0) roaring -= 1;
if (flashing &gt; 0) flashing -= 1;
if (stun &gt; 0) stun -= 1;
if (fxtimer &gt;= 0) fxtimer -= 1;
if (fxtimer == -1) fxtimer = 5;
//stepdelayfinal = stepdelay;
if (boosting &gt; 0) {
    //boosting --;
    //if (speed &lt; 4*boostspdmult) speed = lerp(speed, 4*boostspdmult, 0.2);
    //stepdelayfinal = boostspddelay;
    if (!audio_is_playing(sndSBEris)) {
        sfx_loop(sndSBEris);
    }
    /*if (boosting == 1) {
        boosting = 0;
        event_user(1);
    }*/
} else if (!boosting) {
    sfx_stop(sndSBEris);
}
if (use2) {
    event_user(2);
    use2 = 0;
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="4" ename="oCharacter">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if (state != 100) damage_player(damage, 7, -3, 0, 0);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="4" ename="oBlockMissile">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if (state != 100) with (other) event_user(0);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="14">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Fire projectiles

if (!boosting) {
    if (boostphase &lt; 3) {
        var proj = instance_create(x, y, oErisProjectile);
        proj.direction = point_direction(x, y, oCharacter.x, oCharacter.y-(oCharacter.sprite_height/2));
    } else if (boostphase &lt; 5) {
        var proj = instance_create(x, y, oErisProjectile); // FIXED YAY
        proj.direction = point_direction(x, y, oCharacter.x, oCharacter.y-(oCharacter.sprite_height/2));
        proj.direction += (3);
        var proj2 = instance_create(x, y, oErisProjectile); // FIXED YAY
        proj2.direction = point_direction(x, y, oCharacter.x, oCharacter.y-(oCharacter.sprite_height/2));
        proj2.direction -= (3);
    }
    else {
        for (i = -1; i &lt; 2; i ++) {
            var proj = instance_create(x, y, oErisProjectile); // FIXED YAY
            proj.direction = point_direction(x, y, oCharacter.x, oCharacter.y-(oCharacter.sprite_height/2));
            proj.direction += (i*15);
        }
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="12">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>flashing = 10;
roaring = 30;
sfx_play(sndErisHit);
if (hp &lt; 100 &amp;&amp; hp &gt;= 75) {
    phase = 0;
}
if (hp &lt; 75 &amp;&amp; hp &gt;= 50) {
    phase = 1;
    if (boostphase == 0) {
        boostphase = 1;
    }
}
if (hp &lt; 50 &amp;&amp; hp &gt;= 25) {
    phase = 2;
    if (boostphase == 2) {
        boostphase = 3;
    } 
}
if (hp &lt; 25) {
    phase = 3;
    if (boostphase == 4) {
        boostphase = 5;
    } 
}
if (hp &lt;= 0) {
    state = 100;
    statetime = 0;
}
for (i = 1; i &lt; bodylength - 1; i += 1) {
    mybody[i].flashing = 10;
}
tailobj.flashing = 10;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="11">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if (boosting) {
    if (phase == 0) {
        speedmult = 1*(1+(sign(boosting)));
        stepdelay = 4/(1+(sign(boosting)));
        speed = 3*speedmult;
    } else if (phase == 1) {
        speedmult = 1.1*(1+(sign(boosting)));
        stepdelay = 4/(1+(sign(boosting)));
        speed = 3*speedmult;
    } else if (phase == 2) {
        speedmult = 1.2*(1+(sign(boosting)));
        stepdelay = 3/(1+(sign(boosting)));
        speed = 3*speedmult;
    } else if (phase == 3) {
        speedmult = 1.3*(1+(sign(boosting)));
        stepdelay = 3/(1+(sign(boosting)));
        speed = 3*speedmult;
    }
} else {
    if (phase == 0) {
        speedmult = 1;
        boostspdmult = 3;
        stepdelay = 4;
        boostspddelay = 4/3;
    } else if (phase == 1) {
        speedmult = 1.4;
        boostspdmult = 1.4*3;
        stepdelay = 3;
        boostspddelay = 3
    } else if (phase == 2) {
        speedmult = 1.8;
        boostspdmult = 1.8*3;
        stepdelay = 2;
        boostspddelay = 2/3
    } else if (phase == 3) {
        speedmult = 2.2;
        boostspdmult = 2.2*3;
        stepdelay = 1;
        boostspddelay = 1/3;
    }
}
if (state == 100) speed = 0;
for (l = 0; l &lt;= bodylength; l += 1) {
    prev_x[round(l)] = ds_queue_create();
    prev_y[round(l)] = ds_queue_create();
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="10">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>for (i = 1; i &lt; bodylength - 1; i += 1) {
    mybody[i].image_yscale = image_yscale;
}
tailobj.image_yscale = image_yscale;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>var jawdir;
jawdir = direction + 270 + (image_yscale == -1) * 180;
draw_sprite_ext(sErisJaw, -1, x + lengthdir_x(jawoff+2, jawdir), y + lengthdir_y(jawoff+2, jawdir), 1, image_yscale, image_angle, -1, 1);
draw_sprite_ext(sErisHead, -1, x, y, 1, image_yscale, image_angle, -1, 1);
draw_set_blend_mode(bm_add);
repeat (2) {
    if (flashing &gt; 0) {
        draw_sprite_ext(sErisJaw, -1, x + lengthdir_x(jawoff+2, jawdir), y + lengthdir_y(jawoff+2, jawdir), 1, image_yscale, image_angle, -1, flashing * 0.1);
        draw_sprite_ext(sErisHead, -1, x, y, 1, image_yscale, image_angle, -1, flashing * 0.1);
    }
}
draw_set_blend_mode(bm_normal);
// speedboosting
if (boosting) {
    if (fxtimer == 0 || fxtimer == 1) {
        draw_set_blend_mode(bm_add);
        draw_sprite_ext(sErisJaw, -1, x + lengthdir_x(jawoff+2, jawdir), y + lengthdir_y(jawoff+2, jawdir), 1, image_yscale, image_angle, c_green, 1.1 + fxtimer * 0.2);
        draw_sprite_ext(sErisHead, -1, x, y, 1, image_yscale, image_angle, c_green, 1.1 + fxtimer * 0.2);
        draw_set_blend_mode(bm_normal);
    }
    if (fxtimer == 2 || fxtimer == 3) {
        draw_set_blend_mode(bm_add);
        repeat (2) {
            draw_sprite_ext(sErisJaw, -1, x + lengthdir_x(jawoff+2, jawdir), y + lengthdir_y(jawoff+2, jawdir), 1, image_yscale, image_angle, c_yellow, 1);
            draw_sprite_ext(sErisHead, -1, x, y, 1, image_yscale, image_angle, c_yellow, 1);
            draw_sprite_ext(sErisJaw, -1, x + lengthdir_x(jawoff+2, jawdir), y + lengthdir_y(jawoff+2, jawdir), 1, image_yscale, image_angle, c_white, 1);
            draw_sprite_ext(sErisHead, -1, x, y, 1, image_yscale, image_angle, c_white, 1);
        }
        draw_set_blend_mode(bm_normal);
    }
    if (fxtimer == 4 || fxtimer == 5) {
        draw_set_blend_mode(bm_add);
        repeat (2) {
            draw_sprite_ext(sErisJaw, -1, x + lengthdir_x(jawoff+2, jawdir), y + lengthdir_y(jawoff+2, jawdir), 1, image_yscale, image_angle, c_red, 1);
            draw_sprite_ext(sErisHead, -1, x, y, 1, image_yscale, image_angle, c_red, 1);
        }
        draw_set_blend_mode(bm_normal);
    }

}
// debug
//draw_text(oCharacter.x,oCharacter.y-32,string(state));
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>-1</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
