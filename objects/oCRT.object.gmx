<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>-5000001</depth>
  <persistent>-1</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Initialize variables.

//***********************
// Modifiable properties.
colour_separation = 1; // Separates the red and green pixels left and right, default 1 pixel, more to simulate a broken-TV effect. 
evencolor = 10; // How much of the actual color of the original pixel to blend into the RGB tint, 255: full color (no RGB effect), 0: full RGB simulaton (colors are fully split into RGB their components).
brightness = 0.75; // Brightens and/or oversaturates the image, default 0.5;

static_alpha = 0.10; // Strength of noise drawn over image, the electromagnetic noise effect seen on analog TV sets with low signal.

crt_enabled = true;
draw_3D     = true; // Whether to draw to the curved 3D display or directly to the screen buffer.

screenzoom = 4; // How "zoomed in" the game image is on the CRT monitor, bigger number means smaller image on screen.
//***********************

// Varibles for internal workings.
scanline_large_surface = -1;
large_buffer_surface   = -1; // The filtered image of the game.
large_buffer_surface_2 = -1;
motion_trails_surface = -1;
crt_output_surface = -1; // The output drawn to the CRT monitor.
screen_surface = -1; //The surface that is drawn to the player's screen.

screenwidth  = view_wport[0]*3; // The filtered image is three times the game rendering size.
screenheight = view_hport[0]*3;

shiftx = (screenwidth*screenzoom)/2-view_wport[0]-view_wport[0]/2; // Shifts the image on the CRT monitor.
shifty = (screenheight*screenzoom)/2-view_hport[0]-view_hport[0]/2;

crtshutdown_active = false;
ticks = 0;
duration_ticks = room_speed*3;

// Create the scanline sprite which is then tiled over the screen.
var surf = surface_create(1,3);
surface_set_target(surf); // Make a 1x3 texture, top and bottom pixels clear, middle pixel white.
draw_clear_alpha(c_black, 0);
draw_set_color(c_white); draw_set_alpha(1);
draw_point(0,1); 
surface_reset_target();
spr_scanline = sprite_create_from_surface(surf, 0, 0, surface_get_width(surf), surface_get_height(surf), false, false, 0, 0);
surface_reset_target();
surface_free(surf);

model_curved_screen = d3d_model_create();
d3d_model_load(model_curved_screen, "crt.d3d");
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="1" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Free memory.

draw_set_alpha_test(false);

/*
with(screenBorder){ instance_destroy(); }
with(virtualMouse){ instance_destroy(); }

surface_free(scanline_large_surface);
surface_free(large_buffer_surface);
surface_free(large_buffer_surface_2);

d3d_model_destroy(model_curved_screen);

sprite_delete(spr_scanline);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Center the game window.
/*
if(!window_get_fullscreen())
{
    window_center();
}

window_mouse_set(window_get_width()/2, window_get_height()/2); // Center the mouse in the game window.
*/
//model_curved_screen = d3d_model_create();
d3d_model_load(model_curved_screen, "curved_screen.d3d");
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="2">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>other</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Draw application surface with CRT filter.

// If the CRT filter is not enabled, exit from this script to draw the raw application surface.
if(!crt_enabled or !surface_exists(application_surface)) exit;

// Check if the scanline surface exists, and if not, create it.
if(!surface_exists(scanline_large_surface)) {
    //Create a surface of dark scanlines every three lines
    scanline_large_surface = surface_create(screenwidth, screenheight);
    
    surface_set_target(scanline_large_surface);
    draw_clear_alpha(c_black,0);
    draw_sprite_tiled(spr_scanline, 0, 0, 0);
    surface_reset_target();
}    

if(!surface_exists(large_buffer_surface)) 
    large_buffer_surface = surface_create(screenwidth+2, screenheight+2);

if(!surface_exists(large_buffer_surface_2)) 
    large_buffer_surface_2 = surface_create(screenwidth, screenheight);

if(!surface_exists(motion_trails_surface)) 
    motion_trails_surface = surface_create(screenwidth, screenheight);

if(!surface_exists(crt_output_surface)) 
    crt_output_surface = surface_create(screenwidth*screenzoom, screenheight*screenzoom);

if(!surface_exists(screen_surface)) 
    screen_surface = surface_create(window_get_width(), window_get_height());

surface_set_target(large_buffer_surface);
draw_set_blend_mode(bm_normal);
draw_clear(c_black);
//crtshutdown(); // Active only when quitting the game.
// Draw the application surface (the actual game graphics) to the CRT buffer surface.
draw_surface_ext(application_surface,0,0, //location 
    3,3, //scaling 
    0, c_white, 1.0); //colour and alpha
shader_reset();
draw_set_blend_mode_ext(bm_dest_color, bm_zero); // Should give the product.
// Draw black scanlines over picture.
draw_surface_tiled_ext(scanline_large_surface, 0, 0, 1, 1, c_white, 1.0);
surface_reset_target();


// Now combine pictures onto second buffer, splitting it into RGB colors.
surface_set_target(large_buffer_surface_2);
draw_clear(c_black);
draw_set_blend_mode(bm_add);
draw_surface_tiled_ext(large_buffer_surface,colour_separation,
    -1,1,1,
    make_color_rgb(255,evencolor,evencolor),1.0); // Red.
draw_surface_tiled_ext(large_buffer_surface,-colour_separation,
    0,1,1,
    make_color_rgb(evencolor,255,evencolor),1.0); // Green.
draw_surface_tiled_ext(large_buffer_surface,0,
    +1,1,1,
    make_color_rgb(evencolor,evencolor,255),1.0); // Blue.
draw_set_blend_mode(bm_normal);


// Draw static.
draw_background_tiled_ext(bgCRTStatic, random(256), random(200),
    0.35,0.35,
    c_white, 0.03+0.97*static_alpha*(1-(ticks / duration_ticks)));
surface_reset_target();


// Now draw on to screen, with blur.
surface_set_target(large_buffer_surface);
blur = 1+1.5*brightness; 
draw_clear(make_color_rgb(10,10,10)); // Desaturation.
draw_set_blend_mode(bm_add);
draw_surface_ext(large_buffer_surface_2,1,0, //location
    1,1,0, //scaling and rotation
    c_white, blur/4); //colour and alpha
draw_surface_ext(large_buffer_surface_2,0,1, //location
    1,1,0, //scaling and rotation
    c_white, blur/4); //colour and alpha
draw_surface_ext(large_buffer_surface_2,2,1, //location
    1,1,0, //scaling and rotation
    c_white, blur/4); //colour and alpha
draw_surface_ext(large_buffer_surface_2,1,2, //location
    1,1,0, //scaling and rotation
    c_white, blur/4); //colour and alpha
draw_set_blend_mode(bm_normal);
surface_reset_target();


// Apply trails.
/*surface_set_target(large_buffer_surface);
draw_set_blend_mode(bm_add);
draw_surface_ext(motion_trails_surface,0,0, //location
    1,1,0, //scaling and rotation
    c_orange, 0.15); //colour and alpha
draw_set_blend_mode(bm_normal);
surface_reset_target();

surface_copy(motion_trails_surface, 0, 0, large_buffer_surface);*/


// Create output CRT image.
surface_set_target(crt_output_surface);
draw_clear_alpha(c_black,0);
draw_surface_ext(large_buffer_surface,shiftx-1,shifty-1, //location
    1,1,0, //scaling and rotation
    c_white, 1); //colour and alpha
surface_reset_target();


if(draw_3D) {      
    surface_set_target(screen_surface);
    
    draw_clear_alpha(c_black, 0);
    
    // Draw to a 3D screen.
    d3d_start();
    //draw_set_alpha_test(true);
    d3d_set_camera(); // Set the camera.
    d3d_model_draw(model_curved_screen, 0, 0, 0, surface_get_texture(crt_output_surface)); // Draw the screen.
    d3d_end();
        
    surface_reset_target();
    
    // Draw reflections on sides of the screen.
    /*surface_set_target(crt_output_surface);
    draw_set_blend_mode(bm_subtract);
    var num = 350//388;
    var scale = 1;
    var col1 = make_colour_rgb(16, 16, 16);
    var col2 = make_colour_rgb(8, 8, 8);
    draw_sprite_ext(sReflectionFaderHor, 0, (screenwidth*screenzoom)/2+num, 0, scale, screenheight*screenzoom, 0, c_white, 1); // Right
    draw_sprite_ext(sReflectionFaderHor, 0, (screenwidth*screenzoom)/2-num, 0, -scale, screenheight*screenzoom, 0, c_white, 1); // Left
    draw_sprite_ext(sReflectionFaderVer, 0, 0, shifty, screenwidth*screenzoom, scale, 0, c_white, 1); // Top
    draw_sprite_ext(sReflectionFaderVer, 0, 0, (screenheight*screenzoom) - shifty, screenwidth*screenzoom, -scale, 0, c_white, 1); // Bottom
    draw_set_blend_mode(bm_normal);
    //draw_rectangle_colour((screenwidth*screenzoom)/2-num-5, 0, (screenwidth*screenzoom)/2+num+5, screenheight*screenzoom, col1, col1, col1, col1, false);
    //draw_rectangle_colour((screenwidth*screenzoom)/2-num, 0, (screenwidth*screenzoom)/2+num, screenheight*screenzoom, col2, col2, col2, col2, false);
    //draw_rectangle_colour((screenwidth*screenzoom)/2-num-5, 0, (screenwidth*screenzoom)/2+num+5, screenheight*screenzoom, col1, col1, col1, col1, false);
    draw_rectangle_colour((screenwidth*screenzoom)/2-num, 0, (screenwidth*screenzoom)/2+num, screenheight*screenzoom, c_black, c_black, c_black, c_black, false);
    surface_reset_target();
    
    d3d_start();
    d3d_set_camera();
    
    d3d_transform_add_rotation_z(-270); // Right
    d3d_transform_add_translation(0, 23.26, 0);
    d3d_transform_add_translation(1.775, 0, 0);
    d3d_model_draw(model_curved_screen, 0, 0, 0, surface_get_texture(crt_output_surface));
    d3d_transform_set_identity();
    
    d3d_transform_add_rotation_z(-90); // Left
    d3d_transform_add_translation(0, 23.26, 0);
    d3d_transform_add_translation(-1.775, 0, 0);
    d3d_model_draw(model_curved_screen, 0, 0, 0, surface_get_texture(crt_output_surface));
    d3d_transform_set_identity();
    
    draw_set_alpha_test(false);
    d3d_end();*/
    }
else {
    // Stretch to fit the screen/window;
    var a = application_get_position(),
        xx = a[0],
        yy = a[1],
        ww = a[2] - a[0],
        hh = a[3] - a[1];
        
    // Draw the finished CRT filtered surface directly to the screen.
    draw_surface_stretched(large_buffer_surface, xx, yy, ww, hh);
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="77">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>
if(surface_exists(screen_surface)) {
    // DISABLE ALPHABLEND BECAUSE SURFACES //
    //draw_enable_alphablend(0);
    
    // SET THE SHADER //
    //if(fxaa_on) {
        /*shader_set(sha_fxaa);
        var tex = surface_get_texture(screen_surface);
        shader_set_uniform_f(shader_get_uniform(sha_fxaa, "u_texel"), texture_get_texel_width(tex), texture_get_texel_height(tex));
        shader_set_uniform_f(shader_get_uniform(sha_fxaa, "u_strength"), 10);*/
    //}
    // DRAW THE SURFACE //
    draw_surface(screen_surface, 0, 0);
    // RESET ALPHABLEND //
    //draw_enable_alphablend(1);
    // RESET THE SHADER //
    //shader_reset();
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>605</id>
        <kind>0</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>0</useapplyto>
        <exetype>0</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>Draw nothing.</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="9" enumb="46">
      <action>
        <libid>1</libid>
        <id>332</id>
        <kind>0</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>0</useapplyto>
        <exetype>1</exetype>
        <functionname>action_end_game</functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
      </action>
    </event>
    <event eventtype="9" enumb="32">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/*surface_free(large_buffer_surface);
large_buffer_surface = surface_create(screenwidth+2, screenheight+2);

surface_free(scanline_large_surface);
    scanline_large_surface = surface_create(screenwidth, screenheight);
    
    surface_set_target(scanline_large_surface);
    draw_clear_alpha(c_black,0);
    draw_sprite_tiled(spr_scanline, 0, 0, 0);
    surface_reset_target();

surface_free(large_buffer_surface_2);
    large_buffer_surface_2 = surface_create(screenwidth, screenheight);*/

    
//d3d_model_clear(model_curved_screen); // These shouldn't be needed... but they are.
//alarm[0] = 120;

//crt_creator.alarm[0] = 1;
//instance_destroy();

//model_curved_screen = d3d_model_create();
//d3d_model_load(model_curved_screen, "curved_screen.d3d");
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="9" enumb="27">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Quit

if (crt_enabled) // If the CRT effect is enabled...
{
    crtshutdown_active = true; // ..start the shutdown process to quit the game.
}
else
{
    game_end(); // Directly quit the game.
};
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
